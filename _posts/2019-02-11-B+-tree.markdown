---
layout: post
title:  "【转】B+ Tree"
date:   2019-02-11 12:00:00 -0700
categories: Database
tags: Database B-tree Index
description: 数据库如何聪明地使用一些数据结构建立索引（重点：加速查找 + 读取）
---
### 总结自：
- [数据库索引为什么使用B+树？](https://www.jianshu.com/p/4dbbaaa200c4)
- [平衡二叉树、B树、B+树、B\*树 理解其中一种你就都明白了](https://zhuanlan.zhihu.com/p/27700617)

相关/不相关的一些概念：  
B tree： 二叉树（Binary tree），每个节点只能存储一个数。  
索引大，不可能全部出存在内存中，需要以索引文件的形式储存在磁盘上。  
提速的关键：减少磁盘I/O。具体来说：读取相同磁盘快的同时，尽可能多地加载索引数据，提高命中率。

B-tree：B树。多叉树/平衡多路查找树（不同于平衡二叉树：查找路径不止2个）。每个节点可以多个数（由磁盘大小决定）。
- 每个磁盘块一个节点。节点大小一个页（4k），每个节点只需一次I/O即可完全载入。
- 节点包含对应关键字 + 数据，以及到下面（大中小）枝叶的指针。

B+tree：  B-tree的变种。数据只存在叶子结点中。
- 每个节点存储的关键字数更多 -> 树的层级更少 -> 查询数据更快
- 所有指关键字指针都存在叶子节点 -> 每次查找的次数都相同 -> 查询速度更稳定
- 如果每个节点能存放M个数据，每个节点的数据在M/2到M之间。预留出空间可以插入新的数据。
- 天然具备排序功能：叶子结点是有序链表，查询大小区间的数据时更方便，数据紧密性很高，缓存的命中率也比B树高
- 全节点遍历更快：只需遍历所有叶子结点，不需每层，1有利于数据库做全表扫描

B\*tree：B-tree的变种。每个磁盘块中添加了对下一个磁盘块的引用。
- 在当前磁盘块满时，不用扩容直接存储到下一个临近磁盘块（兄弟节点）中。
- 当两个邻近的磁盘块都满时，这两个磁盘块各分出1/3的数据重新分配一个磁盘块，这样这三个磁盘块的数据都为2/3。
- 如果每个节点能存放M个数据，每个节点的数据在2M/3到M之间。预留出空间可以插入新的数据。
- 在B+树的基础上因其初始化的容量变大，使得节点空间使用率更高，而又存有兄弟节点的指针，可以向兄弟节点转移关键字的特性使得B*树额分解次数变得更少；