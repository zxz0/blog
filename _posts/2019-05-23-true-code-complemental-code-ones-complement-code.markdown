---
layout: post
title:  "【转】原码 补码 反码"
date:   2019-05-23 12:00:00 -0700
categories: Computer
tags: Low-level Concept
description: 原码，补码，反码的概念和理解方法
---
### 摘抄自：
- [原码, 反码, 补码 详解](https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html)

原码：符号位 + 真值的绝对值。正数为0，负数为1。  
- 比如，8位：[1111 1111, 0111 1111] -> [-127, 127]

反码：正数：本身；负数：原码符号位不变，其余各位取反

补码：正数：本身；负数：原码符号位不变，其余各位取反（反码），+ 1

为何？因为人肉眼可以识别符号位，然后直接对之后的做加减；但是计算机加减乘除运算想设计得尽量简单，所以不想辨别“符号位”，于是？让符号位也参与运算！又因为 - 正数 = + 负数，所以只需要设计加法。  
原码减法会错：1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [1000 0010]原 = -2  
反码2个0: 1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0 减法ok：真值正确，但是2个0的编码: +0和-0（[0000 0000]原和[1000 0000]原）。  
补码1个0，并且可以多一个数：1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原。  
可以用[1000 0000]表示-128  
(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]  补（因为是用多出来的补码表示的，所以没有对应的原码和反码表示：如果算回去原码，是[0000 0000]，不正确）  
所以，8位二进制，用原码 / 反码可以[-127, +127]，但用补码: [-128, 127]. ！正0补码表示0，负0补码表示-128！

因为机器使用补码, 所以对于编程中常用到的32位int类型, 可以表示范围是: [-2^31, 2^31 - 1] 因为第一位表示的是符号位.而使用补码表示时又可以多保存一个最小值.

同余：X，Y关于模Z同余（除以Z余数相同）  
负数的模？根据mod运算的数学定义： x mod y = x - y[x/y] // []表示下界  
eg. (-2) mod 12 = -2 - 12 * [-0.几]下界 = -2 - 12 * (-1) = 10  
而 10 mod 12 = 10，同余  
所以在一个12进制的表盘上，回拨2小时 = 往前进10小时  
要用正数代替负数，只要用同余数的两定理：  
a ≡ a (mod m) // 反身性：a和a关于m同余  
如果a ≡ b (mod m)，c ≡ d (mod m) 那么:  
1. a ± c ≡ b ± d (mod m)  
2. a * c ≡ b * d (mod m)  

so:  
7 ≡ 7 (mod 12)  
(-2) ≡ 10 (mod 12)  
7 - 2 ≡ 7 + 10 (mod 12) (为一个负数找到了正数同余数)  
回到编码：  
2 - 1 = 2 + (-1) = [0000 0010]原 + [1000 0001]原= [0000 0010]反 + [1111 1110]反  
若将此[111 1110]反看作是原码，则应该是-126，移去符号位：126  
而有：  
(-1) mod 127 = 126  
126 mod 127 = 126  
即：  
(-1) ≡ 126 (mod 127)  
2-1 ≡ 2+126 (mod 127)  
余数相同，且正是我们希望的2 - 1 = 1  
=> 反码, 实际上是这个数对于一个模的同余数. 而这个模并不是我们的二进制, 而是所能表示的最大值! 这就和钟表一样, 转了一圈后总能找到在可表示范围内的一个正确的数值!（减去一个数，相当于加上这个数的同余数：最后到达同样的刻度，只是多走了一圈而已。这里就是溢出的符号位）  
2+126：相当于钟表转过了一轮, 而因为符号位是参与计算的, 正好和溢出的最高位形成正确的运算结果.  
反码：可以将减法变成加法  

补码：  
2-1=2+(-1) = [0000 0010]原 + [1000 0001]原 = [0000 0010]补 + [1111 1111]补  
若将此[1111 1111]当成原码, 去除符号位, 则:  
[0111 1111]原 = 127  
为何在反码基础上+1？增加了模的值（刻度盘的size）：  
(-1) mod 128 = 127  
127 mod 128 = 127  
2 - 1 ≡ 2 + 127 (mod 128)  
（每128个刻度转一轮，补码范围：[-128, 128]，但是因为0的情况，所以取值范围是[-128, 127]）