<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>zxz0</title>
		<description>Welcome to zxz0！</description>
		<link>http://localhost:4000/blog</link>
		<atom:link href="http://localhost:4000/blog/feed.xml" rel="self" type="application/rss+xml" />
		
			<item>
				<title>GitLab设置SSH key，以及相关知识</title>
				<description>&lt;h3 id=&quot;gitlab设置ssh-key在本地已有ssh-key的情况下&quot;&gt;GitLab设置SSH key（在本地已有SSH key的情况下）&lt;/h3&gt;
&lt;p&gt;环境：macOS 10.14.6
（因为是Mac，所以预装了OpenSSH client。Windows得先装这个再进行以下操作）&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;生成SSH key：
    &lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ssh-keygen &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; ed25519 &lt;span class=&quot;nt&quot;&gt;-C&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;注册用的email&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;ed25519这个数字签名算法是最安全，performance最好的（验证、签名、key生成的速度都快，签名公钥都很小）。如果server支持就用尽量这个。&lt;/li&gt;
      &lt;li&gt;默认且最常用的是RSA。推荐加上-b 4096参数生成4096 bits的key；旧的RSA不安全（仅一轮MD5 hash），推荐在6.5版本之后，加上-o用新方法encode。
        &lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  ssh-keygen &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; rsa &lt;span class=&quot;nt&quot;&gt;-b&lt;/span&gt; 4096 &lt;span class=&quot;nt&quot;&gt;-C&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;注册用的email&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;-C 参数是comment，可不写&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;在被保存SSH key的file的时候，不要用之前GitHub重复的文件（或者说，任何已有的SSH key的文件，否则之前的就会被覆盖 or 退出）。
    &lt;ul&gt;
      &lt;li&gt;默认名字是id_签名算法。如果之前是一路enter，那么就是id_rsa&lt;/li&gt;
      &lt;li&gt;最好保持路径一样：在默认文件夹：~/.ssh下&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;在被问password（passphrase）的时候，为了安全，可以使用。这是为了在本机硬盘上保护私钥。&lt;/li&gt;
  &lt;li&gt;后台启动ssh-agent，将 SSH 私钥添加到 ssh-agent 并将密码存储在密钥链中：
    &lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nb&quot;&gt;eval&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;ssh-agent &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;
 ssh-add ~/.ssh/new_ssh_key
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;创建/修改配置文件，保证本机能够根据host选择对应的私钥：
    &lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; vim ~/.ssh/config
 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;c&quot;&gt;# GitHub&lt;/span&gt;
 Host github.com
   Preferredauthentications publickey
   IdentityFile ~/.ssh/id_rsa

 &lt;span class=&quot;c&quot;&gt;# Private GitLab instance&lt;/span&gt;
 Host gitlab.company.com
   Preferredauthentications publickey
   IdentityFile ~/.ssh/new_ssh_key
 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;esc + : + wq&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;如果之前有使用密码保护私钥，可以用UseKeychain yes设置直接使用keychain，从而不用每次都输passphrase。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;复制公钥到剪切板：
    &lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; pbcopy &amp;lt; ~/.ssh/new_ssh_key.pub
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;如果手动copy，要注意copy所有内容：以ssh-ed25519 / ssh-rsa开始，以使用的email结尾。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;添加公钥到远程服务器：
    &lt;ul&gt;
      &lt;li&gt;大概有可以用的图形界面（GitLab: setting - SSH Keys - Key）&lt;/li&gt;
      &lt;li&gt;如果生成的时候用了-C，那么注释会出现在Title下。如果没有？写个好辨认的title，比如，home，或者Work Laptop。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;验证一下之前的SSH key没有被破坏（此处是GitHub），以及新的SSH key是否添加成功
    &lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; ssh &lt;span class=&quot;nt&quot;&gt;-T&lt;/span&gt; git@github.com
 ssh &lt;span class=&quot;nt&quot;&gt;-T&lt;/span&gt; git@gitlab.company.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;可以加参数-v看到详细验证过程&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;相关背景知识&quot;&gt;相关背景知识&lt;/h3&gt;
&lt;h4 id=&quot;ssh&quot;&gt;SSH&lt;/h4&gt;
&lt;p&gt;用于加密登陆的网络协议（即使被截获，内容也不会泄露），有多种实现。主要用于远程登录（safely administering remote servers）。在2个party间建立安全的连接，互相验证，传递commands和output。&lt;/p&gt;

&lt;h4 id=&quot;ssh工作流程&quot;&gt;SSH工作流程：&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;建立安全信道：此处使用对称加密（双方共享一个key，用于加密和解密；或者一堆关系简单可以推导的key）。
    &lt;ul&gt;
      &lt;li&gt;无论用那种验证方法，都要先建立安全信道&lt;/li&gt;
      &lt;li&gt;这个key是sesson-base，用于保证之后所有的传输的安全&lt;/li&gt;
      &lt;li&gt;可以设置使用不同的symmetrical cipher systems：client有个preference list，最后双方共同选择的是，client的list上尽量靠前的，server也支持的。&lt;/li&gt;
      &lt;li&gt;大概过程是：
        &lt;ol&gt;
          &lt;li&gt;双方共享一个大质数；&lt;/li&gt;
          &lt;li&gt;双方约定encryption generator (eg. AES)；&lt;/li&gt;
          &lt;li&gt;双方各自决定一个秘密的质数，当作私钥；&lt;/li&gt;
          &lt;li&gt;使用这个私钥，还有约定好的相同的encryption generator，和共享的大质数生成公钥。这个公钥可以随意公开，并且公钥无法推导出对应的私钥；&lt;/li&gt;
          &lt;li&gt;双方交换公钥；&lt;/li&gt;
          &lt;li&gt;各方有自己的私钥和对方的公钥，以及一开始共享的大质数，可以计算出一个shared secret key。双方各自计算，但是结果是一样的。&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;最后得到的共同的secret key就是上面所说的sesson-based key，用于双方加密解密接下来的通信&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;验证用户：使用非对称加密（单方向发送数据需要一对associated key：公钥可以随意分享，用于加密；私钥用于解密对应公钥加密的内容。）
    &lt;ul&gt;
      &lt;li&gt;用户名密码：传统方法，像普通的计算机登陆。密码被加密后传送，但是长度有限，可以暴力破解。&lt;/li&gt;
      &lt;li&gt;SSH key：更安全。
        &lt;ul&gt;
          &lt;li&gt;client生成一对key pair。&lt;/li&gt;
          &lt;li&gt;server存公钥（加密），client都有（私钥解密）。&lt;/li&gt;
          &lt;li&gt;server通过验证client有对应私钥验证client身份。&lt;/li&gt;
          &lt;li&gt;client通过第一次连接的时候获取的fingerprint人工手工验证server，只要这个fingerprint不变化，就不会再bother到人（或者在config文件中设置StrickHostKeyChecking no，自动把新的host加入known_hosts，否则第一次连接的时候会询问；UserKnownHostsFile /dev/null，不警告新的或者fingerprint变化的host。）&lt;/li&gt;
          &lt;li&gt;具体验证过程：
            &lt;ol&gt;
              &lt;li&gt;client发送自己的key pair的ID给server；&lt;/li&gt;
              &lt;li&gt;server在对应用户目录下的~/.authorized_keys中查找到对应的公钥；&lt;/li&gt;
              &lt;li&gt;如果found，server生成随机数字，用公钥加密；&lt;/li&gt;
              &lt;li&gt;server发送这个加密后的信息（当然，要使用先前建立好的安全信道，所以还有一道加密。不过这个相当于当前layer下的一层了，可以当作透明，不考虑）；&lt;/li&gt;
              &lt;li&gt;client如果有对应的私钥，就可以成功解密，得到original number；&lt;/li&gt;
              &lt;li&gt;client结合解密后的数字，以及shared session key，计算出MD5值；&lt;/li&gt;
              &lt;li&gt;client发送这个MD5值到server，作为答案；&lt;/li&gt;
              &lt;li&gt;server一样使用shared session key，和自己有的original number计算MD5值。如果一样，则认为client有provate key，验证成功。&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;另外，还会使用hash保证data integrity。&lt;/p&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;参考资料&quot;&gt;参考资料：&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://xuyuan923.github.io/2014/11/04/github-gitlab-ssh/&quot;&gt;github/gitlab同时管理多个ssh key&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/b9f686dfbdb2&quot;&gt;github和gitlab公用，ssh key 配置&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://help.github.com/cn/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent#generating-a-new-ssh-key&quot;&gt;生成新 SSH 密钥并添加到 ssh-agent&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://gitlab.com/help/ssh/README#types-of-ssh-keys-and-which-to-choose&quot;&gt;GitLab and SSH keys&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.digitalocean.com/community/tutorials/understanding-the-ssh-encryption-and-connection-process&quot;&gt;Understanding the SSH Encryption and Connection Process&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.digitalocean.com/community/tutorials/how-to-configure-ssh-key-based-authentication-on-a-linux-server&quot;&gt;How To Configure SSH Key-Based Authentication on a Linux Server&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html&quot;&gt;SSH原理与运用（一）：远程登录&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/gavincoder/p/10054532.html&quot;&gt;Git连接GitLab远程仓库&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.digitalocean.com/community/tutorials/ssh-essentials-working-with-ssh-servers-clients-and-keys&quot;&gt;SSH Essentials: Working with SSH Servers, Clients, and Keys&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.digitalocean.com/community/tutorials/how-to-configure-ssh-key-based-authentication-on-a-linux-server&quot;&gt;How To Configure SSH Key-Based Authentication on a Linux Server&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.digitalocean.com/community/tutorials/understanding-the-ssh-encryption-and-connection-process&quot;&gt;Understanding the SSH Encryption and Connection Process&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/qq_40870418/article/details/78829769&quot;&gt;Diffie-Hellman密钥是如何交换的&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
				<pubDate>Wed, 11 Sep 2019 01:42:00 +0800</pubDate>
				<link>http://localhost:4000/blog/practice/2019/09/11/Gitlab-SSH-key.html</link>
				<guid isPermaLink="true">http://localhost:4000/blog/practice/2019/09/11/Gitlab-SSH-key.html</guid>
			</item>
		
			<item>
				<title>Hello, world!</title>
				<description>&lt;h1 id=&quot;some-heading&quot;&gt;some heading&lt;/h1&gt;

&lt;p&gt;This is my first post.&lt;/p&gt;

&lt;p&gt;Thanks to &lt;a href=&quot;https://medium.com/@satorusasozaki/how-to-create-a-blog-with-jekyll-and-github-page-d6470ab32369&quot;&gt;How to Create a Blog with Jekyll and GitHub Page&lt;/a&gt;, &lt;a href=&quot;https://medium.com/20percentwork/creating-your-blog-for-free-using-jekyll-github-pages-dba37272730a&quot;&gt;Greating your blog for free using Jekyll + Github pages&lt;/a&gt;, &lt;a href=&quot;https://jekyllcn.com&quot;&gt;Jeckll&lt;/a&gt;, &lt;a href=&quot;https://stackoverflow.com/questions/43622325/failed-to-load-resources-with-jekyll-on-a-github-page&quot;&gt;Failed to load resources with Jekyll on a Github page&lt;/a&gt;, &lt;a href=&quot;https://24ways.org/2013/get-started-with-github-pages/&quot;&gt;Get Started With GitHub Pages (Plus Bonus Jekyll)&lt;/a&gt;, &lt;a href=&quot;https://help.github.com/en/articles/configuring-a-publishing-source-for-github-pages&quot;&gt;Configuring a publishing source for GitHub Pages&lt;/a&gt;.&lt;/p&gt;
</description>
				<pubDate>Mon, 19 Aug 2019 15:27:00 +0800</pubDate>
				<link>http://localhost:4000/blog/other/2019/08/19/hello-world.html</link>
				<guid isPermaLink="true">http://localhost:4000/blog/other/2019/08/19/hello-world.html</guid>
			</item>
		
			<item>
				<title>Python的类成员变量默认初始值的坑</title>
				<description>&lt;h2 id=&quot;问题发现一个循环内缺省值初始化同名变量其中的list成员不是空会延续之前同名变量的值&quot;&gt;问题发现：一个循环内，缺省值初始化同名变量，其中的list成员不是空，会延续之前同名变量的值。&lt;/h2&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Define class&lt;/span&gt;
class Variant&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;:
    &lt;span class=&quot;c&quot;&gt;# use&lt;/span&gt;
    def __init__&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;self, price &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 500, description &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'default description'&lt;/span&gt;, values &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;''&lt;/span&gt;, &lt;span class=&quot;s1&quot;&gt;''&lt;/span&gt;, &lt;span class=&quot;s1&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt;:
        self.price &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; price
        self.description &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; description
        self.values &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; values

    def __str__&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;:
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'price: {}, description: {}, values: {}'&lt;/span&gt;.format&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;self.price, self.description, self.values&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

variant_list &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Create instance with same name iteratively&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;i &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;range&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;3&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;:
    current_variant &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; Variant&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;i &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; 1:
        current_variant.values[2] &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'hello'&lt;/span&gt;
    current_variant.price &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; i
    current_variant.description &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'description of variant: {}'&lt;/span&gt;.format&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;i&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    variant_list.append&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;current_variant&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# Test results&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;variant &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;variant_list:
    print&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;str&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;variant&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;
&lt;p&gt;结果：所有实例的values列表值相同
—
原因：“可选参数默认值的设置在Python中只会被执行一次，也就是定义该函数的时候”如此使用缺省值初始化，list成员指向的是同一个list（地址），如果只是修改其中一个元素（而不是赋值新的list开辟新内存），那么所有instance的list成员都会被修改。
—
解决方法：直接在构造方法中置为空（self.values = [’’, ‘’, ‘’]），之后各个修改值
—
reference: &lt;a href=&quot;https://blog.csdn.net/a462533587/article/details/80666444&quot;&gt;Python 类成员变量使用缺省值初始化时要注意的一个坑&lt;/a&gt;
&lt;a href=&quot;https://codingpy.com/article/top-10-mistakes-that-python-programmers-make/&quot;&gt;Python程序员最常犯的十个错误&lt;/a&gt;&lt;/p&gt;
</description>
				<pubDate>Sat, 02 Feb 2019 02:29:45 +0800</pubDate>
				<link>http://localhost:4000/blog/python/2019/02/02/Python-class-member-default-value.html</link>
				<guid isPermaLink="true">http://localhost:4000/blog/python/2019/02/02/Python-class-member-default-value.html</guid>
			</item>
		
			<item>
				<title>家用路由器下Windows系统主机做服务器</title>
				<description>&lt;ol&gt;
  &lt;li&gt;绑定内网ip（参考路由器指南）&lt;/li&gt;
  &lt;li&gt;设置端口转发（参考路由器指南）&lt;/li&gt;
  &lt;li&gt;目标主机上运行服务器（参考具体语言/框架/项目指南）&lt;/li&gt;
  &lt;li&gt;Windows防火墙设置（添加出入allow规则，注意和已有规则的冲突：如果一个服务被block且allow，最终会被block）
注：路由器默认设置为禁止ping&lt;/li&gt;
&lt;/ol&gt;
</description>
				<pubDate>Tue, 06 Nov 2018 06:08:10 +0800</pubDate>
				<link>http://localhost:4000/blog/ops/2018/11/06/Windows-server.html</link>
				<guid isPermaLink="true">http://localhost:4000/blog/ops/2018/11/06/Windows-server.html</guid>
			</item>
		
			<item>
				<title>Python的作用域陷阱</title>
				<description>&lt;p&gt;问题发现：for循环内部的“局部”变量，在出现异常后，赋的变量仍有值可以输出。
每个循环都输出，发现没有重复。&lt;/p&gt;

&lt;p&gt;结论：无for内的“局部”变量。
Python内的变量作用域，最小是以函数为单位。
之上是类，再是模块。&lt;/p&gt;

&lt;p&gt;对于本问题，而输出没有重复，是因为出现异常后就跳出了赋值语句块，输出的设计不好。
实际上输出的值，是上次循环中赋的值。&lt;/p&gt;

&lt;p&gt;延伸阅读：&lt;a href=&quot;https://blog.csdn.net/cc7756789w/article/details/46635383&quot;&gt;Python变量作用域&lt;/a&gt;&lt;/p&gt;
</description>
				<pubDate>Thu, 09 Nov 2017 15:59:35 +0800</pubDate>
				<link>http://localhost:4000/blog/python/2017/11/09/Python-scope.html</link>
				<guid isPermaLink="true">http://localhost:4000/blog/python/2017/11/09/Python-scope.html</guid>
			</item>
		
			<item>
				<title>找不到courses.h文件和telnet命令</title>
				<description>&lt;p&gt;都是不完全安装惹的祸。&lt;/p&gt;

&lt;p&gt;图形界面下：
System——Administration——Add/Remove software&lt;/p&gt;

&lt;p&gt;telnet:
找到
（图片：The client program for the Telnet remote login protocal 和 The server program for the Telnet remote login protocal）
Apply&lt;/p&gt;

&lt;p&gt;courses.h:
找到
（图片缺失）
Apply&lt;/p&gt;
</description>
				<pubDate>Mon, 15 Dec 2014 16:32:07 +0800</pubDate>
				<link>http://localhost:4000/blog/linux/2014/12/15/Linux-install.html</link>
				<guid isPermaLink="true">http://localhost:4000/blog/linux/2014/12/15/Linux-install.html</guid>
			</item>
		
			<item>
				<title>【Linux】 零碎的一些命令</title>
				<description>&lt;p&gt;文档中：
b 上页
空格 下页
q 退出&lt;/p&gt;

&lt;p&gt;文档的命令模式中：
gg=G 自动调整缩进&lt;/p&gt;

&lt;p&gt;.c编译运行：&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;gcc hello.c &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;or:cc hello.c&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./a.out
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上翻下翻：
shift + PgUp
shift + PgDn&lt;/p&gt;

&lt;p&gt;文件/VIM中查找：
/
上一个结果：
N
下一个结果：
n
取消查找：
noh&lt;/p&gt;
</description>
				<pubDate>Tue, 02 Dec 2014 15:33:57 +0800</pubDate>
				<link>http://localhost:4000/blog/linux/2014/12/02/Linux-commands.html</link>
				<guid isPermaLink="true">http://localhost:4000/blog/linux/2014/12/02/Linux-commands.html</guid>
			</item>
		
			<item>
				<title>【Linux】cat一些用法</title>
				<description>&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;name1 name2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;将name1，name2文件一起输出到屏幕（先1后2）&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;创建name文件：内容在标准输入(ctrl+c或ctrl+d退出)（会覆盖原有文件）（实质：重定向到文件）&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;name &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; name2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;把name内容复制创建name2&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在name文件之后添加：内容在标准输入(ctrl+c或ctrl+d退出)&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;name1 name2 &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; name3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;把name1，name2内容连接，添加在name3后。此时可选参数：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;-n 或 –number 由 1 开始对所有输出的行数编号&lt;/li&gt;
  &lt;li&gt;-b 或 –number-nonblank 和 -n 相似，只不过对于空白行不编号&lt;/li&gt;
  &lt;li&gt;-s 或 –squeeze-blank 当遇到有连续两行以上的空白行，就代换为一行的空白行&lt;/li&gt;
  &lt;li&gt;-v 或 –show-nonprinting
    eg. &lt;code class=&quot;highlighter-rouge&quot;&gt;
        $ cat -n name &amp;gt; name2
       &lt;/code&gt; 把name内容复制创建name2
        &lt;code class=&quot;highlighter-rouge&quot;&gt;
        $ cat -b name1 name2 &amp;gt;&amp;gt; name3
       &lt;/code&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cat /dev/null &amp;gt; name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;将name文件置空&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cat &amp;lt;&amp;lt; EOF &amp;gt;&amp;gt; name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在name文件之后添加：内容在标准输入(ctrl+c或ctrl+d或EOF退出)&lt;/p&gt;
</description>
				<pubDate>Tue, 02 Dec 2014 15:30:08 +0800</pubDate>
				<link>http://localhost:4000/blog/linux/2014/12/02/Linux-cat.html</link>
				<guid isPermaLink="true">http://localhost:4000/blog/linux/2014/12/02/Linux-cat.html</guid>
			</item>
		
	</channel>
</rss>
